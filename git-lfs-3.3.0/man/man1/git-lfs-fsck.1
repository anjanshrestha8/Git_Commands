'\" t
.\"     Title: git-lfs-fsck
.\"    Author: [see the "AUTHOR(S)" section]
.\" Generator: Asciidoctor 2.0.18
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "GIT\-LFS\-FSCK" "1" "" "\ \&" "\ \&"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
git-lfs-fsck \- Check GIT LFS files for consistency
.SH "SYNOPSIS"
.sp
\f(CRgit lfs fsck\fP [options] [revisions]
.SH "DESCRIPTION"
.sp
Checks all Git LFS files in the current HEAD for consistency.
.sp
Corrupted files are moved to ".git/lfs/bad".
.sp
The revisions may be specified as either a single committish, in which
case only that commit is inspected; specified as a range of the form
\f(CRA..B\fP (and only this form), in which case that range is inspected; or
omitted entirely, in which case HEAD (and, for \-\-objects, the index) is
examined.
.sp
The default is to perform all checks.
.sp
In your Git configuration or in a \f(CR.lfsconfig\fP file, you may set
\f(CRlfs.fetchexclude\fP to a comma\-separated list of paths. If
\f(CRlfs.fetchexclude\fP is defined, then any Git LFS files whose paths match
one in that list will not be checked for consistency. Paths are matched
using wildcard matching as per gitignore(5).
.SH "OPTIONS"
.sp
\f(CR\-\-objects\fP
.RS 4
Check that each object in HEAD matches its expected hash
and that each object exists on disk.
.RE
.sp
\f(CR\-\-pointers\fP
.RS 4
Check that each pointer is canonical and that each file
which should be stored as a Git LFS file is so stored.
.RE
.SH "SEE ALSO"
.sp
git\-lfs\-ls\-files(1), git\-lfs\-status(1), gitignore(5).
.sp
Part of the git\-lfs(1) suite.