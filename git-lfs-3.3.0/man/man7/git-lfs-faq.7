'\" t
.\"     Title: git-lfs-faq
.\"    Author: [see the "AUTHOR(S)" section]
.\" Generator: Asciidoctor 2.0.18
.\"    Manual: \ \&
.\"    Source: \ \&
.\"  Language: English
.\"
.TH "GIT\-LFS\-FAQ" "7" "" "\ \&" "\ \&"
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.ss \n[.ss] 0
.nh
.ad l
.de URL
\fI\\$2\fP <\\$1>\\$3
..
.als MTO URL
.if \n[.g] \{\
.  mso www.tmac
.  am URL
.    ad l
.  .
.  am MTO
.    ad l
.  .
.  LINKSTYLE blue R < >
.\}
.SH "NAME"
git-lfs-faq \- FAQ for Git LFS
.SH "ENTRIES"
.sp
Does Git LFS provide a way to track files by size?
.RS 4
No, it doesn\(cqt.  Unfortunately, Git itself doesn\(cqt specify a way to make
\f(CR.gitattributes\fP patterns apply to files of a certain size and we rely on
the \f(CR.gitattributes\fP file to specify which files are tracked by Git LFS.
.sp
You \fIcan\fP use the \f(CR\-\-above\fP option to \f(CRgit lfs migrate import\fP to migrate
all files that at the specified time are larger than a certain size.  However,
if your files change to be smaller or larger in the future, or you add more
files in the future that are larger than the limit you specified, you will have
to track them manually.
.sp
For these reasons, we recommend using patterns rather than \f(CR\-\-above\fP.
.RE
.sp
Why doesn\(cqt Git LFS handle files larger than 4 GiB on Windows?
.RS 4
Git LFS itself handles these files just fine.  However, Git LFS is usually
invoked by Git, and until Git 2.34, Git itself on Windows didn\(cqt handle files
using smudge and clean filters (like Git LFS) that are larger than 4 GiB.
So you can update Git for Windows to 2.34 to natively support these file sizes.
.sp
On older versions, set \f(CRGIT_LFS_SKIP_SMUDGE\fP to \f(CR1\fP and run \f(CRgit lfs pull\fP
to pull down the LFS files.  This bypasses Git\(cqs smudging functionality
and therefore avoids its limitations.
.RE
.sp
Why do I end up with small text files in my working tree instead of my files?
.RS 4
Git LFS stores small text files called pointer files in the repository instead
of your large files, which it stores elsewhere.  These pointer files usually
start with the line \f(CRversion \c
.URL "https://git\-lfs.github.com/spec/v1" "" "\fP."
.sp
Normally, if you\(cqve run \f(CRgit lfs install\fP at least once for your user account on
the system, then Git LFS will be automatically invoked by Git when you check out
files or clone a repository and this won\(cqt happen.  However, if you haven\(cqt, or
you\(cqve explicitly chosen to skip that behaviour by using the \f(CR\-\-skip\-smudge\fP
option of \f(CRgit lfs install\fP, then you may need to use \f(CRgit lfs pull\fP to replace
the pointer files in your working tree with large files.
.RE
.sp
Why do I end up with some of my working tree files constantly showing as modified?
.RS 4
This can happen if someone made a commit to a file that\(cqs tracked by Git LFS
but didn\(cqt have Git LFS properly set up on their system.  The objects that
were checked into the repository are Git objects, not the pointers to Git LFS
objects, and when Git checks these files out, it shows them as modified.
.sp
There are also several other possible ways to encounter this problem, such as an
incomplete migration of your repository.  For example, you should not use \f(CRgit
lfs track\fP to track patterns that are already in your repository without running
\f(CRgit add \-\-renormalize .\fP, since that can lead to this problem.
.sp
Users frequently find that this cannot be changed by doing \f(CRgit reset \-\-hard\fP or
other techniques because Git then checks the files out and marks them as
modified again.  The best way to solve this problem is by fixing the files and
the committing the change, which you can do with the following on an otherwise
clean tree:
.sp
.if n .RS 4
.nf
.fam C
$ git add \-\-renormalize .
$ git commit \-m "Fix broken LFS files"
.fam
.fi
.if n .RE
.sp
This requires that every branch you want to fix have this done to it.
.sp
To prevent this from reoccurring in the future, make sure that everyone working
with large files on a project has run \f(CRgit lfs install\fP at least once.  The
command \f(CRgit lfs fsck \-\-pointers BASE..HEAD\fP (with suitable values of \f(CRBASE\fP and
\f(CRHEAD\fP) may be used in your CI system to verify that nobody is introducing such
problems.
.RE
.sp
How do I track files that are already in a repository?
.RS 4
If you want to track files that already exist in a repository, you need to do
two things.  First, you need to use \f(CRgit lfs track\fP (or a manual modification
of \f(CR.gitattributes\fP) to mark the files as LFS files.  Then, you need to run
\f(CRgit add \-\-renormalize .\fP and commit the changes to the repository.
.sp
If you skip this second step, then you\(cqll end up with files that are marked as
LFS files but are stored as Git files, which can lead to files which are always
modified, as outlined in the FAQ entry above.  Note also that this doesn\(cqt
change large files in your history.  To do that, use \f(CRgit lfs migrate import
\-\-everything\fP instead, as specified in one of the entries below.
.RE
.sp
How do I enable git diff to work on LFS files?
.RS 4
You can run \f(CRgit config diff.lfs.textconv cat\fP, which will produce normal
diffs if your files are text files.
.RE
.sp
How do I enable git diff to work on LFS files based on extension or path?
.RS 4
If the above solution is too broad, each entry in the \f(CR.gitattributes\fP file
can be customized by creating a custom global converter:
.sp
.if n .RS 4
.nf
.fam C
$ git config \-\-global diff.lfstext.textconv cat
.fam
.fi
.if n .RE
.sp
Any given \f(CR.gitattributes\fP entry for large text files can be customized to use
this global text converter (e.g., patch files), whereas binary formats can
continue to use the conventional lfs diff tool, like so:
.sp
.if n .RS 4
.nf
.fam C
$ cat .gitattributes
\&....
*.bin filter=lfs diff=lfs merge=lfs \-text
*.patch filter=lfs diff=lfstext merge=lfs \-text
\&....
.fam
.fi
.if n .RE
.sp
Be advised that all developers sharing this repo with such a modified
\f(CR.gitattributes\fP file must have similarly configured the \f(CRlfstext\fP text
converter, whether globally or on a per repository basis.
.RE
.sp
How do I convert from using Git LFS to a plain Git repository?
.RS 4
If you\(cqd like to stop using Git LFS and switch back to storing your large
files in the plain Git format, you can do so with \f(CRgit lfs migrate export
\-\-everything\fP.  Note that you will need to provide an appropriate \f(CR\-\-include\fP
option to match all the patterns that you currently have tracked in any ref.
.sp
This also rewrites history, so the Git object IDs of many, if not all, of your
objects will change.
.RE
.sp
I\(cqm using Git LFS, but I still see GitHub\(cqs large file error.  How do I fix this?
.RS 4
GitHub rejects large files anywhere in the history of your repository, not
just in the latest commit.  If you\(cqre still seeing this message, then you have
some large files somewhere in your history, even if in the latest commits
you\(cqve moved them to Git LFS.
.sp
To fix this, you can use \f(CRgit lfs migrate import \-\-everything\fP with an
appropriate \f(CR\-\-include\fP argument.  For example, if you wanted to move your
\f(CR.jpg\fP and \f(CR.png\fP files into Git LFS, you can do that with
\f(CRgit lfs migrate import \-\-everything \-\-include="*.jpg,*.png"\fP.  More complicated
patterns are possible: run \f(CRgit help gitattributes\fP for more information on
valid patterns.  Note that if you\(cqre specifying directories, using slashes is
mandatory: backslashes are not allowed as path separators.
.RE
.SH "SEE ALSO"
.sp
git\-config(1), git\-lfs\-install(1), gitattributes(5), gitignore(5).
.sp
Part of the git\-lfs(1) suite.